<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.bluexiii.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Git简介什么是版本控制版本控制系统（Version Control System，简称VCS）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 按类型可以分为：    本地版本控制系统例如RCS（至少我是从来没有用过）本地版本控制系统解决了版本的管理问题，再也不用时不时的把工程目录，通过手工拷贝的方式来存档了。但本地版本控制系统的缺点是，无法解决多人协作的问题。  集中化的">
<meta property="og:type" content="article">
<meta property="og:title" content="Git内部培训课件">
<meta property="og:url" content="http://blog.bluexiii.com/201612/Git%E5%86%85%E9%83%A8%E5%9F%B9%E8%AE%AD%E8%AF%BE%E4%BB%B6-%E5%85%AC%E5%BC%80%E7%89%88/index.html">
<meta property="og:site_name" content="BlueXIII&#39;s Blog">
<meta property="og:description" content="Git简介什么是版本控制版本控制系统（Version Control System，简称VCS）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 按类型可以分为：    本地版本控制系统例如RCS（至少我是从来没有用过）本地版本控制系统解决了版本的管理问题，再也不用时不时的把工程目录，通过手工拷贝的方式来存档了。但本地版本控制系统的缺点是，无法解决多人协作的问题。  集中化的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-18333fig0101-tn.png">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-011528.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-011814.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-015752.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/dkkiz.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/wirgm.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/pr68v.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/p69yw.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/8wm7e.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/ufspp.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/7fm9z.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/5ixt6.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/z7r01.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/ha8wl.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/xwmo5.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/yt3l3.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/wf4i2.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/q33ki.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/p88bo.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/mgh91.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/gbveu.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/xfrf7.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/vs6o3.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/hh1wm.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/v3a5l.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/w3swt.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/bl7k3.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/mqmex.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/cscqb.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/aal3p.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/4wfxt.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/z6u9t.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/s1fru.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/3zu6i.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/h6vla.jpg">
<meta property="og:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/5cgpa.jpg">
<meta property="article:published_time" content="2016-12-15T02:01:46.000Z">
<meta property="article:modified_time" content="2021-01-26T01:44:33.850Z">
<meta property="article:author" content="BlueXIII">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-18333fig0101-tn.png">

<link rel="canonical" href="http://blog.bluexiii.com/201612/Git%E5%86%85%E9%83%A8%E5%9F%B9%E8%AE%AD%E8%AF%BE%E4%BB%B6-%E5%85%AC%E5%BC%80%E7%89%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Git内部培训课件 | BlueXIII's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BlueXIII's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">热爱技术,持续学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.bluexiii.com/201612/Git%E5%86%85%E9%83%A8%E5%9F%B9%E8%AE%AD%E8%AF%BE%E4%BB%B6-%E5%85%AC%E5%BC%80%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="BlueXIII">
      <meta itemprop="description" content="IT技术类文章、笔记分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BlueXIII's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Git内部培训课件
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-15 10:01:46" itemprop="dateCreated datePublished" datetime="2016-12-15T10:01:46+08:00">2016-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-26 09:44:33" itemprop="dateModified" datetime="2021-01-26T09:44:33+08:00">2021-01-26</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><h3 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h3><p>版本控制系统（Version Control System，简称VCS）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>按类型可以分为：  </p>
<ul>
<li><p>本地版本控制系统<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-18333fig0101-tn.png"><br>例如RCS（至少我是从来没有用过）<br>本地版本控制系统解决了版本的管理问题，再也不用时不时的把工程目录，通过手工拷贝的方式来存档了。但本地版本控制系统的缺点是，无法解决多人协作的问题。</p>
</li>
<li><p>集中化的版本控制系统<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-011528.jpg"><br>例如CVS，SVN等（公司中SVN应该用的比较多）<br>有一个集中管理的服务器，所有开发人员通过客户端连到这台服务器，取出最新的 <strong>文件</strong> 或者提交更新。管理员可以掌控每个开发者的权限。<br>集中化的VCS不但解决了版本控制问题，还可以多人协作。但缺点也是有的，就是太依赖于远程服务器，CVS服务器宕机后，会影响所有人的工作。版本记录只保存在一台服务器上，会有数据丢失风险。</p>
</li>
<li><p>分布式版本控制系统<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-011814.jpg"><br>例如Git<br>客户端并不只提取最新版本的文件，而是把 <strong>代码仓库</strong> 完整地镜像下来。每一次的提取操作，实际上都是一次对 <strong>代码仓库</strong> 的完整备份。<br>所以并没有”中心服务器”的概念，所谓的”Git服务器”，也同每个人的电脑一样，只是为了多人协作时，方便大家交换数据而已。    </p>
</li>
</ul>
<h3 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h3><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）<br>好不好用，看看它的开发者是谁就知道了：Linux之父 Linus Torvalds</p>
<p>小历史： Linux内核社区原本使用的是名为BitKeeper的商业化版本控制工具，2005年，因为社区内有人试图破解BitKeeper的协议，BitMover公司收回了免费使用BitKeeper的权力。<br>Linus原本可以出面道个歉，继续使用BitKeeper，然而并没有。。。Linus大神仅用了两周时间，自已用C写了一个分布式版本控制系统，于是Git诞生了！<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/2016-12-08-015752.jpg">  </p>
<h3 id="为什么要使用Git"><a href="#为什么要使用Git" class="headerlink" title="为什么要使用Git"></a>为什么要使用Git</h3><p>为什么要使用Git，或者说Git相比SVN有什么优势呢？</p>
<ul>
<li><p>分布式<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/dkkiz.jpg">  </p>
</li>
<li><p>分支管理<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/wirgm.jpg">  </p>
</li>
<li><p>GitHub<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/pr68v.jpg"></p>
</li>
</ul>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul>
<li>大多数Linux发行版已经预装了Git，系统默认自带，如果不带。。可以源码make安装或使用yum/apt等直接安装，过程不赘述了。  </li>
<li>macOS下，安装Xcode后，它的CLI工具里应该会包含Git了。或者使用brew手工安装一下。</li>
<li>Windows下，可以直接下载安装 <a target="_blank" rel="noopener" href="https://git-for-windows.github.io/">msysGit</a> 。  或者如果你的机器上已经有Cygwin，也可以直接用在它下面安装Git。  </li>
<li>图形工具推荐使用 <a target="_blank" rel="noopener" href="https://www.sourcetreeapp.com/">SourceTree</a>，查看分支非常直观 。IntelliJ IDEA等IDE也会自带一些图形化的工具，在合并代码时很高效。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/p69yw.jpg"></li>
</ul>
<h3 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h3><ul>
<li>首先，忘掉SVN/CVS，不要把Git的各种操作与它们做类比，切记。  </li>
<li>刚开始不要依赖图形客户端。首先应该将精力用在理解原理上 -&gt; 然后掌握一些基本CLI命令，动手操作实践 -&gt; 最后在实际工作中使用GUI工具以提高效率。  </li>
<li>重度Windows用户使用Git时，与平时熟悉GUI的环境会有些违和感，毕竟Git是Linux下的产物，Git遵循Linux的哲学，Simple，简单直接，但Simple并不等于Easy。需要转换一下思维。</li>
</ul>
<h2 id="了解Git的工作原理"><a href="#了解Git的工作原理" class="headerlink" title="了解Git的工作原理"></a>了解Git的工作原理</h2><h3 id="记录文件整体快照"><a href="#记录文件整体快照" class="headerlink" title="记录文件整体快照"></a>记录文件整体快照</h3><p>Git和其他版本控制系统的主要差别在于，Git只关心文件数据的 <strong>整体</strong> 是否发生变化，而大多数其他系统则只关心 <strong>文件内容</strong> 的具体差异。</p>
<p>SVN在每个版本中，以单一文件为单位，记录各个文件的差异：<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/8wm7e.jpg"></p>
<p>Git在每个版本中，以当时的全部文件为单位，记录一个快照：<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/ufspp.jpg"></p>
<h3 id="大多数操作都在本地执行"><a href="#大多数操作都在本地执行" class="headerlink" title="大多数操作都在本地执行"></a>大多数操作都在本地执行</h3><p>Git的绝大多数操作都只需要访问本地文件和资源，不用连网。因为你的本机上，就已经是完整的代码库了。这样一来，在无法连接公司内网的环境中，也可以愉快的写代码了。<br>例如，如果想看当前版本的文件和一个月前的版本之间有何差异，Git会取出一个月前的快照和当前文件作一次差异运算，而不用每次都请求远程服务器。</p>
<h3 id="时刻保持数据完整性"><a href="#时刻保持数据完整性" class="headerlink" title="时刻保持数据完整性"></a>时刻保持数据完整性</h3><p>在保存到Git之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。<br>这项特性作为Git的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git都能立即察觉。<br>Git使用SHA-1算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个SHA-1哈希值，作为指纹字符串。该字串由40个十六进制字符组成，看起来就像是：<br><code>24b9da6552252987aa493b52f8696cd6d3b00373</code><br>Git的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</p>
<h3 id="多数操作仅添加数据"><a href="#多数操作仅添加数据" class="headerlink" title="多数操作仅添加数据"></a>多数操作仅添加数据</h3><p>常用的Git操作大多仅仅是把数据添加到数据库，很难让Git执行任何不可逆操作。在Git中一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。  </p>
<h3 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h3><p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed） 已修改（modified） 已暂存（staged）<br>已提交表示该文件已经被安全地保存在本地数据库中了；<br>已修改表示修改了某个文件，但还没有提交保存；<br>已暂存表示把已修改的文件放在下次提交时要保存的清单中。  </p>
<p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/7fm9z.jpg"></p>
<p>每个项目都有一个名为.git的目录，它是 Git用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。<br>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从Git目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。<br>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。  </p>
<p>基本的 Git 工作流程如下：  </p>
<ol>
<li>在工作目录中修改某些文件。</li>
<li>对修改后的文件进行快照，然后保存到暂存区域。</li>
<li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ol>
<p>所以，我们可以从文件所处的位置来判断状态：如果是Git目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>有两种取得Git项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的Git仓库。 第二种是从已有的Git仓库克隆出一个新的镜像仓库来。</p>
<h3 id="在目录中创建新仓库"><a href="#在目录中创建新仓库" class="headerlink" title="在目录中创建新仓库"></a>在目录中创建新仓库</h3><p>如果一个目录还没有使用Git进行管理，只需到此项目所在的目录，执行<code>git init</code>，初始化后，在当前目录下会出现一个名为.git的目录  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<h3 id="从已有的仓库克隆"><a href="#从已有的仓库克隆" class="headerlink" title="从已有的仓库克隆"></a>从已有的仓库克隆</h3><p>如果Git项目已经存在，可以使用<code>git clone</code>从远程服务器上复制一份出来，Git支持多种协议：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone mobgit@134.32.51.60:learngit.git  #使用SSH传输协议</span><br><span class="line">$ git clone git:&#x2F;&#x2F;134.32.51.60&#x2F;learngit.git  #使用Git传输协议</span><br><span class="line">$ git clone https:&#x2F;&#x2F;134.32.51.60&#x2F;learngit.git  #使用HTTPS传输协议</span><br></pre></td></tr></table></figure>

<h2 id="版本库基本操作"><a href="#版本库基本操作" class="headerlink" title="版本库基本操作"></a>版本库基本操作</h2><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>使用<code>git status</code>命令可以查看文件的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Initial commit</span><br><span class="line">nothing to commit (create&#x2F;copy files and use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p>出现如上的提示，说明现在的工作目录相当干净，所有已跟踪文件在上次提交后都未被更改过。</p>
<p>现在我们做一些改动，添加一个readme.txt进去，然后再看一下状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat&gt;readme.txt</span><br><span class="line">hello git</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">	readme.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>
<p>Untracked files显示了这个新创建的readme.txt处于未跟跟踪状态</p>
<h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用<code>git add</code>命令开始跟踪一个新文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   readme.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/5ixt6.jpg"><br>readme.txt已 <strong>被跟踪</strong> ，并处于 <strong>暂存状态</strong></p>
<h3 id="将本次修改暂存"><a href="#将本次修改暂存" class="headerlink" title="将本次修改暂存"></a>将本次修改暂存</h3><p>现在我们再对readme.txt进行修改，添加一行，再执行<code>git status</code>查看状态  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   readme.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/z7r01.jpg"></p>
<p>可以看到readme.txt 不仅出现在了Changes to be committed，还出现在了Changes not staged for commit<br>由此可见，Git关心的是 <strong>Changes</strong> ，而不是文件本身。<br>再次执行<code>git add</code>，可以将 <strong>本次修改</strong> 提交到暂存区，Changes not staged for commit提示消失<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/ha8wl.jpg"></p>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>使用<code>git commit</code>命令将暂存区中的内容提交至版本库，工作区又是干净的了  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;my first commit&quot;</span><br><span class="line">[master (root-commit) 6c8912a] my first commit</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is based on &#39;origin&#x2F;master&#39;, but the upstream is gone.</span><br><span class="line">  (use &quot;git branch --unset-upstream&quot; to fixup)</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>注意：一定要使用-m参数加入注释，认真描述本次的提交具体做了些什么，这对于以后我们查询历史记录非常重要。  </p>
<p>如果觉得使用暂存区过于繁琐，可以在commit时直接使用-a参数，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;my first commit&quot;</span><br></pre></td></tr></table></figure>
<h3 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h3><p>使用<code>git log</code>命令可以查看历史记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 43c5d337ffdd76f33ce5f5f90103d57e55474956</span><br><span class="line">Author: BlueXIII &lt;bluexiii@163.com&gt;</span><br><span class="line">Date:   Thu Dec 8 14:45:59 2016 +0800</span><br><span class="line"></span><br><span class="line">    this is my second commit</span><br><span class="line"></span><br><span class="line">commit 6c8912ad2a8e90a7ba32cc8578fd0069a205221b</span><br><span class="line">Author: BlueXIII &lt;bluexiii@163.com&gt;</span><br><span class="line">Date:   Thu Dec 8 14:38:09 2016 +0800</span><br><span class="line"></span><br><span class="line">    my first commit</span><br></pre></td></tr></table></figure>
<p>可以看到，每次更新都有一个SHA-1校验和、作者的名字和电子邮件地址、提交时间、提交说明。</p>
<h3 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h3><p>撤消操作在这里这里不做重点描述了，只列出几个常用命令。<br>修改最后一次提交：<br>git commit –amend<br>取消已经暂存的文件：<br>git reset HEAD readme.txt<br>取消对文件的修改：<br>git checkout – readme.txt</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>之前介绍了在本地仓库的一些操作。但当与他人协作开发某个项目时，需要至少使用一个远程仓库，以便推送或拉取数据，分享各自的工作进展。  </p>
<h3 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h3><p>之前已经在讲新建仓库时已经提到，如何克隆远程库，这里再重复列一遍：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone mobgit@134.32.51.60:learngit.git  #使用SSH传输协议</span><br><span class="line">$ git clone git:&#x2F;&#x2F;134.32.51.60&#x2F;learngit.git  #使用Git传输协议</span><br><span class="line">$ git clone https:&#x2F;&#x2F;134.32.51.60&#x2F;learngit.git  #使用HTTPS传输协议</span><br></pre></td></tr></table></figure>
<h3 id="查看绑定的远程库"><a href="#查看绑定的远程库" class="headerlink" title="查看绑定的远程库"></a>查看绑定的远程库</h3><p>如果之前我们使用的<code>git clone</code>命令直接克隆了一个远程仓库到本机，Git就已经默认绑定了一个名为origin的远程库。当然我们还可以手工绑定其它远程库，远程仓库可以有多个。<br>使用<code>git remote -v</code>命令列出我们绑定了哪些远程库：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin	mobgit@134.32.51.60:learngit.git (fetch)</span><br><span class="line">origin	mobgit@134.32.51.60:learngit.git (push)</span><br></pre></td></tr></table></figure>
<p>接下来还可以使用<code>git remote show origin</code>来查看这个名为origin的远程库的更详细的信息，这里先不细讲  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: mobgit@134.32.51.60:learngit.git</span><br><span class="line">  Push  URL: mobgit@134.32.51.60:learngit.git</span><br><span class="line">  HEAD branch (remote HEAD is ambiguous, may be one of the following):</span><br><span class="line">    dev</span><br><span class="line">    master</span><br><span class="line">    serverfix</span><br><span class="line">    serverfix2</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev        tracked</span><br><span class="line">    master     tracked</span><br><span class="line">    serverfix  tracked</span><br><span class="line">    serverfix2 tracked</span><br><span class="line">  Local branches configured for &#39;git pull&#39;:</span><br><span class="line">    dev        merges with remote dev</span><br><span class="line">    master     merges with remote master</span><br><span class="line">    serverfix  merges with remote serverfix</span><br><span class="line">    serverfix2 merges with remote serverfix2</span><br><span class="line">  Local refs configured for &#39;git push&#39;:</span><br><span class="line">    dev        pushes to dev        (up to date)</span><br><span class="line">    master     pushes to master     (up to date)</span><br><span class="line">    serverfix  pushes to serverfix  (up to date)</span><br><span class="line">    serverfix2 pushes to serverfix2 (up to date)</span><br></pre></td></tr></table></figure>
<h3 id="手工添加一个远程仓库"><a href="#手工添加一个远程仓库" class="headerlink" title="手工添加一个远程仓库"></a>手工添加一个远程仓库</h3><p>我们先让管理员新建一个名为learngit2的远程仓库，再使用<code>remote add</code>命令将它添加进来，取名为repo2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add repo2 mobgit@134.32.51.60:learngit2.git</span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">origin	mobgit@134.32.51.60:learngit.git (fetch)</span><br><span class="line">origin	mobgit@134.32.51.60:learngit.git (push)</span><br><span class="line">repo2	mobgit@134.32.51.60:learngit2.git (fetch)</span><br><span class="line">repo2	mobgit@134.32.51.60:learngit2.git (push)</span><br></pre></td></tr></table></figure>
<p>现在我们有origin和repo2两个远程仓库了</p>
<h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><p>使用<code>git fetch [remote-name]</code>从远程仓库抓取数据，注意fetch命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支(关于分支稍后讲解)<br>例如要抓取名为origin远程仓库：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure>
<h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><p>使用<code>git push [remote-name] [branch-name]</code>将本机的工作成果推送到远程仓库<br>例如要将本地的master分支推送到origin远程仓库上：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>也许到之前为止，大家会觉得Git和Svn除了实现原理不同以及实现了分布式之外，在日常使用上并没有什么太大的区别（甚至更繁琐）。但接下来的分支，才是Git的精髓部分。  </p>
<h3 id="为什么要使用分支"><a href="#为什么要使用分支" class="headerlink" title="为什么要使用分支"></a>为什么要使用分支</h3><p>举个简单的例子：假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。<br>于是你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。<br>相比于Svn等工具，Git创建、切换分支的开销是非常小的，Git鼓励 <strong>频繁使用分支</strong>  </p>
<h3 id="分支的原理"><a href="#分支的原理" class="headerlink" title="分支的原理"></a>分支的原理</h3><p>要理解分支，需要继续深入一下Git的工作原理</p>
<h4 id="Git如何储存数据"><a href="#Git如何储存数据" class="headerlink" title="Git如何储存数据"></a>Git如何储存数据</h4><p>在Git中提交时，会保存一个提交对象（commit object），该对象包含一个指向暂存内容快照的指针，并同时包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针（首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先）。  </p>
<p>假设在工作目录中有三个文件已经 <strong>修改</strong> 过，准备将它们暂存后提交。<br><code>git add</code>暂存操作时，会对 <strong>每一个文件</strong> 计算校验和，然后把当前版本的文件快照使用 <strong>blog对象</strong> 保存到Git仓库中（为提高性能，若文件没有变化，Git不会再次保存）。将它们的SHA-1校验和加入到暂存区域等待提交。<br><code>git commit</code>提交操作，时，Git首先会计算 <strong>每一个子目录</strong> 的校验和，然后将这些校验和保存为 <strong>tree对象</strong> 。 然后Git会创建一个 <strong>commit对象</strong> ，它包含指向这个树对象的指针及注释、提交人、邮箱等信息。<br>现在，Git仓库中有五个对象：三个blob 对象（保存着文件快照）;一个树对象（记录着目录结构和blob对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。</p>
<p>单个提交对象在仓库中的数据结构：<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/xwmo5.jpg"><br>多个提交对象之间的链接关系：<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/yt3l3.jpg">  </p>
<h4 id="分支是什么"><a href="#分支是什么" class="headerlink" title="分支是什么"></a>分支是什么</h4><p><strong>Git 中的分支，其实本质上仅仅是个指向commit对象的可变指针</strong>。Git会使用master作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次commit对象的master分支。它在每次提交的时候都会自动向前移动。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/wf4i2.jpg"></p>
<p>创建名为testing的新的分支，本质上就是创建一个指针，可以使用<code>git branch</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/q33ki.jpg"></p>
<h4 id="当前工作在哪个分支"><a href="#当前工作在哪个分支" class="headerlink" title="当前工作在哪个分支"></a>当前工作在哪个分支</h4><p>Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它还保存着一个名为HEAD的特别指针。它是一个指向你正在工作中的本地分支的指针。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/p88bo.jpg"></p>
<h4 id="切换分支时发生了什么"><a href="#切换分支时发生了什么" class="headerlink" title="切换分支时发生了什么"></a>切换分支时发生了什么</h4><p>切换分支，本质上就是移动HEAD指针。<br>要切换到其他分支，可以执行<code>git checkout</code>命令。我们现在转换到刚才新建的testing分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/mgh91.jpg"></p>
<h3 id="分支切换的实际操作"><a href="#分支切换的实际操作" class="headerlink" title="分支切换的实际操作"></a>分支切换的实际操作</h3><p>为了更好的理解分支，我们接下来模拟实际工作中的场景，进行一系列的切换操作。<br>现在我们已经处于testing分支了，目前testing分支和master分支都是指向同一个commit，所以我们的工作区的内容现在还没有什么变化。<br>现在，我们要在testing分支上做一些文件修改，然后commit:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;testing branch&quot;&gt;&gt;readme.txt</span><br><span class="line">git commit -a -m &quot;modify on testing branch&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/gbveu.jpg"><br>提交后，产生了一个新的commit对象，并且HEAD随着当前testing分支一起向前移动。而master分支则是停在原地不动。</p>
<p>我们可以试着使用<code>git checkout</code>命令切回master分支，看看发生了什么:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/xfrf7.jpg"><br>这条命令做了两件事：  </p>
<ol>
<li>它把HEAD指针移回到 master 分支。</li>
<li>把工作目录中的文件换成了master分支所指向的快照内容。</li>
</ol>
<p>我们试着在master上再做一些改动并commit：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;testing master&quot;&gt;&gt;readme.txt</span><br><span class="line">git commit -a -m &quot;modify on master branch&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/vs6o3.jpg"><br>现在分支变成了上图所示，我们可以在master与testing间随时切换，并修改工作区的文件内容。必要时再将这两个分支合并。</p>
<h3 id="分支新建与合并的实际操作"><a href="#分支新建与合并的实际操作" class="headerlink" title="分支新建与合并的实际操作"></a>分支新建与合并的实际操作</h3><p>接下来，再以一个比较长的真实的工作场景进行举例</p>
<p>我们首先在master分支上进行工作，并提交了几次更新，测试无误后编译发布至生产系统。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/hh1wm.jpg"></p>
<p>之后我们决定要修补问题追踪系统上的53号问题，这时可以使用<code>git checkout -b</code>命令快速创建一个分支并切换过去：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br></pre></td></tr></table></figure>
<p>这相当于执行了下面这两条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/v3a5l.jpg"></p>
<p>我们在iss53分支上写了一些代码，并commit  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi index.html</span><br><span class="line">$ git commit -a -m &#39;fixed the broken email address&#39;</span><br></pre></td></tr></table></figure>
<p>iss53上的工作还没完成，突然接到通知，生产系统有一个紧急BUG需要立刻修复。所以我们首先切回master分支，然后在master的基础上，又新建出一个hotfix分支来修复BUG。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master    #回到master分支</span><br><span class="line">$ git checkout -b hotfix    #新建一个hotfix分支，并切过去</span><br><span class="line">$ vim index.html    #修改一些东西，修复BUG</span><br><span class="line">$ git commit -a -m &#39;fixed the broken email address&#39;    #提交hotfix</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/w3swt.jpg"></p>
<p>在hotfix分支上搞定BUG之后，我们切回master分支，使用<code>git merge</code>把刚才的hotfix合并进来  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master  #切换回master分支</span><br><span class="line">$ git merge hotfix    #将hotfix分支的修改，合并到当前master分支来（注意merge的方向，是从其它分支，合到当前分支）。</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/bl7k3.jpg"><br>备注：本次合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把 master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。  </p>
<p>这时hotfix分支已经没用了，可以删掉了  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix    #只是删除了一个指针</span><br></pre></td></tr></table></figure>
<p>现在回到之前未完成的53号问题上，继续写一些代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#39;finished the new footer [issue 53]&#39;</span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/mqmex.jpg"></p>
<p>在问题53相关的工作完成之后，可以合并回master分支。实际操作同前面合并hotfix分支差不多，只需回到master分支，运行git merge命令指定要合并进来的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging README</span><br><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line"> README | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/cscqb.jpg"><br>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。  </p>
<p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/aal3p.jpg"><br>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。  </p>
<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，需要手工来处理冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Git作了合并，但没有提交，它会停下来等你解决冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vi index.html</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;contact : email.support@github.com&lt;&#x2F;div&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">  please contact us at support@github.com</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure>
<p>可以看到 ======= 隔开的上半部分是 HEAD，即master，下半部分是在iss53分支中的内容。<br>手工合并代码后，把 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行也一并删除。这时可以用git commit来提交了。  </p>
<h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>实际开发中，对于分支的管理，已经有很多最佳实践，大多数情况下，我们只需要遵守一些基本原则：  </p>
<ul>
<li>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面工作。  </li>
<li>平时的开发工作都放在dev分支上，也就是说，dev分支是不稳定的。到某个时候，比如测试通过，需要1.2版本发布时，再把dev分支合并到master上，在master分支编译发布1.2版本。  </li>
<li>针对新需求、修复等具体的任务，每次都在dev分支上开一个新的任务分支出来，工作完成后，再向dev分支上合并就可以了。名称没有特别的规范，可以是人名，例如：zhangsan，也可以是任务名、需求编号等，例如：iss03、feature04、hotfix。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/4wfxt.jpg"></li>
</ul>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>之前讨论过远程仓库，接着又学习了分支，当二者结合到一起时，又会产生一些有趣的东西。</p>
<h4 id="远程分支的概念"><a href="#远程分支的概念" class="headerlink" title="远程分支的概念"></a>远程分支的概念</h4><p>远程分支（remote branch）,即远程仓库中的分支。同步到本地后，与本地分支不同的是，它们 <strong>无法移动</strong> ；且只有在Git进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支(例如origin/master)。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/z6u9t.jpg">  </p>
<p>如果我们在本地master分支做了些改动，与此同时，其他人向远程仓库推送了他们的更新，那么服务器上的master分支就会向前推进，而于此同时，我们在本地的提交历史正朝向不同方向发展。（不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动。）<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/s1fru.jpg"></p>
<p>可以运行<code>git fetch origin</code>来同步远程服务器上的数据到本地。该命令首先找到origin是哪个服务器，然后从上面获取你尚未拥有的数据，更新你本地的数据库，然后把origin/master的指针移到它最新的位置上。<br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/3zu6i.jpg"></p>
<p>可以使用<code>git remote</code>命令查看远程仓库的详情  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v    #列出远程服务器清单</span><br><span class="line">origin	mobgit@134.32.51.60:learngit.git (fetch)</span><br><span class="line">origin	mobgit@134.32.51.60:learngit.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote show origin   #查询某一个远程服务器的详情</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: mobgit@134.32.51.60:learngit.git</span><br><span class="line">  Push  URL: mobgit@134.32.51.60:learngit.git</span><br><span class="line">  HEAD branch (remote HEAD is ambiguous, may be one of the following):</span><br><span class="line">    dev</span><br><span class="line">    master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev    tracked</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &#39;git pull&#39;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#39;git push&#39;:</span><br><span class="line">    master pushes to master (up to date)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h4><p>从远程分支checkout出来的本地分支，称为跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。<br>在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 <code>git pull</code> 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin&#x2F;serverfix</span><br><span class="line">或简化为：</span><br><span class="line">$ git checkout --track origin&#x2F;serverfix</span><br></pre></td></tr></table></figure>
<p>这会新建并切换到serverfix本地分支，其内容同远程分支origin/serverfix一致。</p>
<h4 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h4><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。<br>例如本地有一个serverfix分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名)：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Compressing objects: 100% (14&#x2F;14), done.</span><br><span class="line">Writing objects: 100% (15&#x2F;15), 1.74 KiB, done.</span><br><span class="line">Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon&#x2F;simplegit.git</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>
<p>或者加入–set-upstream设置跟踪后，以后直接使用<code>git push</code>就可以推送了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin serverfix</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>[GitHub]（<a target="_blank" rel="noopener" href="https://github.com)是一个面向开源及私有软件项目的托管平台,因为只支持git作为唯一的版本库格式进行托管,故名github./">https://github.com）是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。</a><br><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/h6vla.jpg"><br>GitHub本身没有什么好学的，随便看就知道怎么用了 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20070065">知乎：怎样使用GitHub</a><br>重点是，GitHub上有非常多优秀的个人项目值得我们学习，我们也可以将自已的代码发布上去。可以看成是程序员的博客吧，只贴代码，不废话。<br>在GitHub上发布开源项目是免费的，但是私有项目收费。</p>
<h2 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h2><p>GitLab是一个用Ruby on Rails写的开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。<br>可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。<br>GitLab是目前搭建内部Git服务器的首选，当然如果要求不高的话，我们也可以直接使用SSH协议来快速搭建Git服务端。</p>
<h2 id="常用Git命令清单"><a href="#常用Git命令清单" class="headerlink" title="常用Git命令清单"></a>常用Git命令清单</h2><p><img src="https://bluexiii.oss-cn-beijing.aliyuncs.com/5cgpa.jpg"><br>更多内容请直接参考 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰的网络日志</a></p>
<h2 id="推荐文档"><a href="#推荐文档" class="headerlink" title="推荐文档"></a>推荐文档</h2><p>不要指忘2小时的培训能带来多大的收益，最简单高效的方式，还是要多看优秀的文档。<br>本文大量参(chao)考(xi)了以下两部文档：<br><a target="_blank" rel="noopener" href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰的在线教程</a>  适合快速上手<br><a target="_blank" rel="noopener" href="https://www.gitbook.com/book/0532/progit/details">Pro Git中文版</a>   中文第一版  </p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/201611/%E4%BD%BF%E7%94%A8%E6%A0%91%E9%9C%89%E6%B4%BE%E6%90%AD%E5%BB%BASOCKS5%E9%80%8F%E6%98%8E%E7%BD%91%E5%85%B3/" rel="prev" title="使用树莓派搭建SOCKS5透明网关">
      <i class="fa fa-chevron-left"></i> 使用树莓派搭建SOCKS5透明网关
    </a></div>
      <div class="post-nav-item">
    <a href="/201612/AIX%E4%B8%8B%E4%BD%BF%E7%94%A8zip+split%E5%AE%9E%E7%8E%B0%E5%88%86%E5%8D%B7%E5%8E%8B%E7%BC%A9/" rel="next" title="AIX下使用zip+split实现分卷压缩">
      AIX下使用zip+split实现分卷压缩 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Git%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">Git简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">什么是版本控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFGit"><span class="nav-number">1.2.</span> <span class="nav-text">什么是Git</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Git"><span class="nav-number">1.3.</span> <span class="nav-text">为什么要使用Git</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85Git"><span class="nav-number">1.4.</span> <span class="nav-text">安装Git</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84"><span class="nav-number">1.5.</span> <span class="nav-text">学习路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3Git%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">了解Git的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6%E6%95%B4%E4%BD%93%E5%BF%AB%E7%85%A7"><span class="nav-number">2.1.</span> <span class="nav-text">记录文件整体快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%93%8D%E4%BD%9C%E9%83%BD%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C"><span class="nav-number">2.2.</span> <span class="nav-text">大多数操作都在本地执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%88%BB%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">2.3.</span> <span class="nav-text">时刻保持数据完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%95%B0%E6%93%8D%E4%BD%9C%E4%BB%85%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="nav-number">2.4.</span> <span class="nav-text">多数操作仅添加数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">2.5.</span> <span class="nav-text">文件的三种状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">创建版本库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%93%E5%BA%93"><span class="nav-number">3.1.</span> <span class="nav-text">在目录中创建新仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%B7%B2%E6%9C%89%E7%9A%84%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86"><span class="nav-number">3.2.</span> <span class="nav-text">从已有的仓库克隆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9C%AC%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">版本库基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="nav-number">4.1.</span> <span class="nav-text">检查当前文件状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E6%96%B0%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">跟踪新文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%9C%AC%E6%AC%A1%E4%BF%AE%E6%94%B9%E6%9A%82%E5%AD%98"><span class="nav-number">4.3.</span> <span class="nav-text">将本次修改暂存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0"><span class="nav-number">4.4.</span> <span class="nav-text">提交更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2"><span class="nav-number">4.5.</span> <span class="nav-text">查看历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C"><span class="nav-number">4.6.</span> <span class="nav-text">撤消操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">5.</span> <span class="nav-text">远程仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E5%BA%93"><span class="nav-number">5.1.</span> <span class="nav-text">克隆远程库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%BB%91%E5%AE%9A%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%BA%93"><span class="nav-number">5.2.</span> <span class="nav-text">查看绑定的远程库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%B7%A5%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">5.3.</span> <span class="nav-text">手工添加一个远程仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">5.4.</span> <span class="nav-text">从远程仓库抓取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">5.5.</span> <span class="nav-text">推送数据到远程仓库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF"><span class="nav-number">6.</span> <span class="nav-text">分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E6%94%AF"><span class="nav-number">6.1.</span> <span class="nav-text">为什么要使用分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">分支的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Git%E5%A6%82%E4%BD%95%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.1.</span> <span class="nav-text">Git如何储存数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.2.2.</span> <span class="nav-text">分支是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">6.2.3.</span> <span class="nav-text">当前工作在哪个分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">6.2.4.</span> <span class="nav-text">切换分支时发生了什么</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="nav-number">6.3.</span> <span class="nav-text">分支切换的实际操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E7%9A%84%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="nav-number">6.4.</span> <span class="nav-text">分支新建与合并的实际操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5"><span class="nav-number">6.5.</span> <span class="nav-text">分支策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.6.</span> <span class="nav-text">远程分支</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">6.6.1.</span> <span class="nav-text">远程分支的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.6.2.</span> <span class="nav-text">跟踪远程分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">6.6.3.</span> <span class="nav-text">推送本地分支</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GitHub"><span class="nav-number">7.</span> <span class="nav-text">GitHub</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GitLab"><span class="nav-number">8.</span> <span class="nav-text">GitLab</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95"><span class="nav-number">9.</span> <span class="nav-text">常用Git命令清单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E6%96%87%E6%A1%A3"><span class="nav-number">10.</span> <span class="nav-text">推荐文档</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">BlueXIII</p>
  <div class="site-description" itemprop="description">IT技术类文章、笔记分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">223</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xiiiblue" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiiiblue" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/bluexiii" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;bluexiii" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备18050487号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BlueXIII</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
